import { ParameterSchema, Schema, ViewSchema } from '@taquito/michelson-encoder';
import { EntrypointsResponse, RpcClientInterface, ScriptResponse } from '@taquito/rpc';
import { Wallet } from '../wallet';
import { ContractMethod } from './contract-methods/contract-method-flat-param';
import { ContractMethodObject } from './contract-methods/contract-method-object-param';
import { OnChainView } from './contract-methods/contract-on-chain-view';
import { ContractProvider, StorageProvider } from './interface';
export declare const DEFAULT_SMART_CONTRACT_METHOD_NAME = "default";
/**
 * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method
 */
export declare class ContractView {
    private currentContract;
    private provider;
    private name;
    private chainId;
    private callbackParametersSchema;
    private parameterSchema;
    private args;
    constructor(currentContract: ContractAbstraction<ContractProvider | Wallet>, provider: ContractProvider, name: string, chainId: string, callbackParametersSchema: ParameterSchema, parameterSchema: ParameterSchema, args: any[]);
    /**
     *
     * @description Find which lambda contract to use based on the current network,
     * encode parameters to Michelson,
     * create an instance of Lambdaview to retrive data, and
     * Decode Michelson response
     *
     * @param Options Address of a lambda contract (sandbox users)
     */
    read(customLambdaAddress?: string): Promise<any>;
}
export declare type Contract = ContractAbstraction<ContractProvider>;
export declare type WalletContract = ContractAbstraction<Wallet>;
/**
 * @description Smart contract abstraction
 */
export declare class ContractAbstraction<T extends ContractProvider | Wallet> {
    readonly address: string;
    readonly script: ScriptResponse;
    private storageProvider;
    readonly entrypoints: EntrypointsResponse;
    private chainId;
    private contractMethodFactory;
    /**
     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
     *
     */
    methods: {
        [key: string]: (...args: any[]) => ContractMethod<T>;
    };
    /**
     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
     * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)
     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
     *
     */
    methodsObject: {
        [key: string]: (args?: any) => ContractMethodObject<T>;
    };
    /**
     * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.
     * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.
     */
    views: {
        [key: string]: (...args: any[]) => ContractView;
    };
    /**
     * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.
     * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.
     *
     */
    contractViews: {
        [key: string]: (args?: any) => OnChainView;
    };
    readonly schema: Schema;
    readonly parameterSchema: ParameterSchema;
    readonly viewSchema: ViewSchema[];
    constructor(address: string, script: ScriptResponse, provider: T, storageProvider: StorageProvider, entrypoints: EntrypointsResponse, chainId: string, rpc: RpcClientInterface);
    private _initializeMethods;
    private _initializeOnChainViews;
    /**
     * @description Return a friendly representation of the smart contract storage
     */
    storage<T>(): Promise<T>;
    /**
     *
     * @description Return a friendly representation of the smart contract big map value
     *
     * @param key BigMap key to fetch
     *
     * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
     *
     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
     */
    bigMap(key: string): Promise<unknown>;
}
